package me.clip.deluxetags;

import java.util.List;
import java.util.UUID;

import me.clip.deluxetags.commands.TagCommand;
import me.clip.deluxetags.config.ConfigWrapper;
import me.clip.deluxetags.config.Lang;
import me.clip.deluxetags.config.TagConfig;
import me.clip.deluxetags.gui.GUIHandler;
import me.clip.deluxetags.gui.GUIOptions;
import me.clip.deluxetags.gui.TagGUI;
import me.clip.deluxetags.listeners.ChatFormatListener;
import me.clip.deluxetags.listeners.ChatListener;
import me.clip.deluxetags.listeners.JoinListener;
import me.clip.deluxetags.listeners.PlayerListener;
import me.clip.deluxetags.placeholders.TagPlaceholders;
import me.clip.deluxetags.tags.DeluxeTag;
import me.clip.deluxetags.tags.DeluxeTagsHandler;
import me.clip.deluxetags.tasks.CleanupTask;
import me.clip.deluxetags.updater.UpdateChecker;
import me.clip.deluxetags.utils.MsgUtils;
import me.clip.placeholderapi.PlaceholderAPI;
import org.bukkit.Bukkit;
import org.bukkit.command.PluginCommand;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitTask;

/**
 * DeluxeTags plugin
 * 
 * @author Ryan McCarthy
 */
public class DeluxeTags extends JavaPlugin {

	private static final DeluxeTag DUMMY_TAG = new DeluxeTag(420691337, "", "", "");

	private DeluxeTagsHandler tagsHandler;
	private TagConfig cfg;
	private ConfigWrapper messages;
	private ConfigWrapper playerFile;
	private GUIHandler guiHandler;
	private GUIOptions guiOptions;
	private BukkitTask cleanupTask = null;

	private static boolean papi;

	@Override
	public void onEnable() {
		tagsHandler = new DeluxeTagsHandler(this);

		cfg = new TagConfig(this);
		cfg.loadDefConfig();

		final boolean useLegacyHexPattern = cfg.legacyHex();
		MsgUtils.setPattern(useLegacyHexPattern);
		if (useLegacyHexPattern) {
			getLogger().info("Using legacy hex colors format: &#aaFF00");
		} else {
			getLogger().info("Using standard hex colors format: #aaFF00");
		}

		int loaded = cfg.loadTags();
		if (loaded == 1) {
			getLogger().info("1 tag loaded");
		} else {
			getLogger().info(loaded + " tags loaded");
		}

		playerFile = new ConfigWrapper(this, "userdata", "player_tags.yml");
		
		playerFile.createNewFile(null, "DeluxeTags player_tags.yml\nDo not edit this file!");	
		
		cleanupTask = Bukkit.getScheduler().runTaskTimerAsynchronously(this, new CleanupTask(this), 20L*300, 20L*300);
		
		guiOptions = new GUIOptions(this);
		
		guiHandler = new GUIHandler(this);
		
		Bukkit.getPluginManager().registerEvents(guiHandler, this);

		PluginCommand command = getCommand("tags");
		if (command != null) command.setExecutor(new TagCommand(this));
		
		Bukkit.getPluginManager().registerEvents(new PlayerListener(this), this);
		
		if (cfg.loadTagOnJoin()) {
			Bukkit.getPluginManager().registerEvents(new JoinListener(this), this);
		}
		
		messages = new ConfigWrapper(this, null, "messages.yml");

		messages.createNewFile("Loading DeluxeTags messages.yml",
				"DeluxeTags messages.yml\nEdit the plugin messages to your liking!");

		loadMessages();
		
		papi = Bukkit.getPluginManager().getPlugin("PlaceholderAPI") != null;

		if (cfg.papiChat()) {
			getLogger().info("PAPI Chat enabled. This means your chat plugin will use placeholders to fetch the tags!");
		} else {
			if (cfg.formatChat()) {
				Bukkit.getPluginManager().registerEvents(new ChatFormatListener(this), this);
			}

			Bukkit.getPluginManager().registerEvents(new ChatListener(this), this);

			getLogger().info("You are not using a chat plugin that supports PlaceholderAPI!");
			getLogger().info("DeluxeTags will listen to the AsyncPlayerChatEvent to provide compatibility for some chat plugins.");
		}

		if (papi) {
			new TagPlaceholders(this).register();
		}
		
		if (cfg.checkUpdates()) {
			UpdateChecker updater = new UpdateChecker(this);
			updater.fetch();
		
			if (updater.hasUpdateAvailable()) {
				getLogger().info("----------------------------");
				getLogger().info("     DeluxeTags Updater");
				getLogger().info(" ");
				getLogger().info("An update for DeluxeThat has been found!");
				getLogger().info("DeluxeTags " + updater.getSpigotVersion());
				getLogger().info("You are running " + getDescription().getVersion());
				getLogger().info(" ");
				getLogger().info("Download at https://www.spigotmc.org/resources/deluxetags.4390/");
				getLogger().info("----------------------------");

			} else {
				getLogger().info("----------------------------");
				getLogger().info("     DeluxeTags Updater");
				getLogger().info(" ");
				getLogger().info("You are running " + getDescription().getVersion());
				getLogger().info("The latest version");
				getLogger().info("of DeluxeTags!");
				getLogger().info(" ");
				getLogger().info("----------------------------");
			}				
		}
	}
	
	@Override
	public void onDisable() {
		if (cleanupTask != null) {
			cleanupTask.cancel();
			cleanupTask = null;	
		}
		
		this.getTagsHandler().unloadData();
		TagGUI.unload();
		
		guiOptions = null;
	}

	public DeluxeTagsHandler getTagsHandler() {
		return tagsHandler;
	}

	public TagConfig getCfg() {
		return cfg;
	}

	public DeluxeTag getDummyTag() {
		return DUMMY_TAG;
	}

	public GUIHandler getGUIHandler() {
		return guiHandler;
	}

	public GUIOptions getGuiOptions() {
		return guiOptions;
	}

	public ConfigWrapper getPlayerFile() {
		return playerFile;
	}

	public ConfigWrapper getLangFile() {
		return messages;
	}

	public static boolean papi() {
		return papi;
	}

	public String getSavedTagIdentifier(String uuid) {
		FileConfiguration c = playerFile.getConfig();
		if (c.contains(uuid) && c.isString(uuid) && c.getString(uuid) != null) {
			return c.getString(uuid);
		}
		return null;
	}
	
	public void saveTagIdentifier(String uuid, String tagIdentifier) {
		FileConfiguration c = playerFile.getConfig();
		c.set(uuid, tagIdentifier);
		playerFile.saveConfig();
	}
	
	public void removeSavedTag(String uuid) {
		FileConfiguration c = playerFile.getConfig();
		if (c.contains(uuid)) {
			c.set(uuid, null);
			playerFile.saveConfig();
		}
	}
	
	public void removeSavedTags(List<UUID> uuids) {
		boolean requiresSave = false;
		FileConfiguration config = playerFile.getConfig();

		if (uuids == null || uuids.isEmpty()) {
			return;
		}

		for (UUID uuid : uuids) {
			if (config.contains(uuid.toString())) {
				config.set(uuid.toString(), null);
				requiresSave = true;
			}
		}

		if (requiresSave) {
			playerFile.saveConfig();
		}
	}
	
	public void loadMessages() {
		Lang.setFile(messages.getConfig());

		for (final Lang value : Lang.values()) {
			messages.getConfig().addDefault(value.getPath(), value.getDefault());
		}

		messages.getConfig().options().copyDefaults(true);
		messages.saveConfig();
	}

	public void reloadGUIOptions() {
		guiOptions = new GUIOptions(this);
	}

	public String setPlaceholders(Player p, String s, DeluxeTag tag) {
		if (tag == null) {
			tag = this.getTagsHandler().getPlayerActiveTag(p);
		}
		
		if (tag == null) {
			tag = DUMMY_TAG;
		}

		List<String> tags = this.getTagsHandler().getPlayerAvailableTagIdentifiers(p);
		String tagId = tag.getIdentifier() != null ? tag.getIdentifier() : "";
		String amount = tags != null ? String.valueOf(tags.size()) : "0";
		String availability = tag.hasPermissionToUse(p)
			? Lang.GUI_PLACEHOLDERS_TAG_AVAILABLE.getConfigValue(null)
			: Lang.GUI_PLACEHOLDERS_TAG_UNAVAILABLE.getConfigValue(null);

		s = s
			.replace("%player%", p.getName())
			.replace("{player}", p.getName())
			.replace("%displayname%", p.getDisplayName())
			.replace("{displayname}", p.getDisplayName())
			.replace("%deluxetags_tag%", tag.getDisplayTag(p))
			.replace("{deluxetags_tag}", tag.getDisplayTag(p))
			.replace("%deluxetags_identifier%", tagId)
			.replace("{deluxetags_identifier}", tagId)
			.replace("%deluxetags_description%", tag.getDescription(p))
			.replace("{deluxetags_description}", tag.getDescription(p))
			.replace("%deluxetags_amount%", amount)
			.replace("{deluxetags_amount}", amount)
			.replace("%deluxetags_available%", availability)
			.replace("{deluxetags_available}", availability);
		
		if (papi) {
			s = PlaceholderAPI.setPlaceholders(p, s);
		}

		return MsgUtils.color(s);
	}
}